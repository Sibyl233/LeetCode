### 992-K个不同整数的子数组

#### 分解

感觉这个解法很难想到

1. 正好有 K 个不同整数的最长子数组的长度
2. 最多有 K 个不同整数的子数组的个数
3. 正好有 K 个不同整数的子数组的个数 = 最多有 K 个不同整数的子数组的个数 - 最多有 K - 1 个不同整数的子数组的个数

#### 正好有 K 个不同整数的最长子数组的长度

用滑动窗口实现：

- 使用一个字典 cnt，保存窗口内每个数字出现的次数；
- 使用一个变量 distinct 表示该窗口中有几个不同数字，确保正好有 K 个不同整数。distinct 也可以用 len(cnt) 来代替。

```python
def atMostK(A, K):
    left = right = 0
    cnt = collections.Counter()
    distinct = 0
    res = 0
    while right < len(A):
        if cnt[A[right]] == 0:
            distinct += 1
        cnt[A[right]] += 1
        while distinct > K:
            cnt[A[left]] -= 1
            if cnt[A[left]] == 0:
                distinct -= 1
            left += 1
        res = max(right - left + 1) # 注意
        right += 1
    return res
```

#### 最多有 K 个不同整数的子数组的个数

只需要将问题1中的 `res = max(right - left + 1)` 替换成 `res += right - left + 1` 就可以解决问题2。这样做的合理性可以分两点来理解：

1. `right - left + 1`  表示什么？

   因为 `res` 的每次更新都发生在跳出 `while distinct > K` 循环后，即 `res` 更新时满足 `distinct <= K `，所以在任意一轮循环中此时求得的 [left, right] 区间必然是一个最多有K个不同整数的数组。

   - 在问题1中，`right - left + 1`  表示该区间的长度，通过保存较大值可以确保最后的结果为正好有 K 个不同整数的最长子数组的长度；

   - 在问题2中，可理解为将该区间的右端点固定、左端点不断右移而得到的 `right - left + 1` 个符合问题2题意的子数组。

2. 为什么累加即可？

   虽然已经说明了  `right - left + 1`  个数组是符合问题2题意的，但还要保证累加每一次 `while right < len(A)`  循环的  `right - left + 1`  这样的操作能够准确记录子数组的个数，既不重复也不遗漏。不妨直接用具体的例子来理解，以 `A = [1,2,1,2,3], K = 2` 为例，共有12个满足题意的子数组：

   - 以第一个 1 为右端点的满足题意的子数组为 [1]；
   - 以第一个 2 为右端点的满足题意的子数组为 [1,2], [2]；
   - 以第二个 1 为右端点的满足题意的子数组为 [1,2,1], [2,1], [1]；
   - 以第二个 2 为右端点的满足题意的子数组为 [1,2,1,2], [2,1,2], [1,2], [2]；
   - 以最后的 3 为右端点的满足题意的子数组为 [2,3], [3]。

#### 正好有 K 个不同整数的子数组的个数

即最后返回 `atMostK(A,K) - atMostK(A,K-1)`。同样以 `A = [1,2,1,2,3], K = 2` 为例，显然当 K = 1时，满足问题2题意的子数组只有 [1], [2], [1], [2], [3] 这 5 个，所以最后的结果为 12 - 5 = 7

#### 参考

1. [民间题解](https://leetcode-cn.com/problems/subarrays-with-k-different-integers/solution/cong-zui-jian-dan-de-wen-ti-yi-bu-bu-tuo-7f4v/)

