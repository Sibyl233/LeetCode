排序

#### 分类依据

- 平均时间复杂度
  - O(n^2)：冒泡排序、插入排序、选择排序
  - O(logn)：希尔排序、归并排序、快速排序、堆排序
  - O(n+k) / O(nk)：计数排序、桶排序、基数排序
- 是否占用额外内存
  - 内排序：除外排序的 4 个
  - 外排序：归并排序、计数排序、桶排序、基数排序
- 稳定性
  - 稳定：除不稳定的 4 个
  - 不稳定：选择排序、希尔排序、快速排序、堆排序

#### 方法联系

- 冒泡排序 -> 选择排序 -> 快速排序
- 插入排序的升级版 -> 希尔排序
- 计数排序的升级版 -> 桶排序；计数排序的特殊情况 -> 基数排序

#### 方法简介

##### 1. 冒泡排序

- 原理：重复遍历序列，交换相邻两元素；小的元素会通过交换慢慢浮到序列前端。
- 优化：设立标志位 `swapped`。若在某次遍历中元素没有发生交换，则证明该序列已经有序，退出循环。但这种改进对于提升性能来说没有什么太大作用。
- 时间复杂度：正序是最好情况 O(n)；逆序是最坏情况 O(n^2)；平均是 O(n^2)。
- 空间复杂度：O(1)，内排序。
- 稳定性：交换相邻元素，两个数相等时没必要交换，稳定。

##### 2. 选择排序

- 原理：首先在未排序序列中找到最小元素，存放到排序序列的起始位置；然后，从剩余未排序元素中继续寻找最小元素，放到已排序序列的末尾。
- 时间复杂度：正序是最好情况，不需要交换；逆序是最坏情况，需要交换。但时间复杂度始终是O(n^2)，遍历次数不受输入数据影响。
- 空间复杂度：O(1)，内排序。
- 稳定性：跨距离交换，不稳定。

##### 3. 插入排序

- 原理：对于未排序元素，在已排序序列中**从后向前**扫描，找到相应位置并插入。
- 时间复杂度：正序是最好情况 O(n)；逆序是最坏情况 O(n^2)；平均是 O(n^2)。
- 空间复杂度：O(1)，内排序。
- 稳定性：交换相邻元素，两个数相等时没必要交换，稳定。

##### 4. 希尔排序

- 背景：对于**大规模乱序数组**，**插入排序**很慢（只能交换相邻元素，数组末尾的小元素回到数组前段很费劲），所以考虑将原序列跳跃分割成若干子序列，分别进行插入排序，减少插入排序的工作量。
- 原理：实现时，在插入排序的基础上将元素移动的距离由 1 改为 gap 即可，并且逐步缩小 gap 直至为 1。其中 {gap} 被称为**增量序列**，一般采用逐步折半的增量方法。
- 时间复杂度；和增量序列相关，平均是 O(nlogn)。
- 空间复杂度：O(1)，内排序。
- 稳定性：跨距离交换，不稳定。

##### 5. 归并排序

- 原理：采用分治法。①先将数组分成子序列；②让子序列有序；③再将子序列间有序，合并成有序数组。
- 时间复杂度：对长度为 n 的序列，需进行 logn 次二路归并，每趟归并时间为O(n)，故其时间复杂度是O(nlgn)
- 空间复杂度：外排序。每次递归需要用到一个辅助数组，长度与待排序数组相等，但每次递归都会释放掉占用的辅助空间，所以空间复杂度是O(n)。
- 稳定性：不改变元素相对位置，稳定。

##### 6. 快速排序

- 原理：选取一个“哨兵” pivot，将小于 pivot 放在左边，把大于 pivot 放在右边，分割成两部分，从而固定 pivot 在数组的位置，再对分别对左右两部分继续排序。
- 实现：具体实现时，用两个指针 i，j 分别从数组头尾遍历数组，直至找到比 pivot 大的左侧元素和比 pivot 小的右侧元素，并交换两者。当 i > j 时说明所有小于 pivot 的元素和所有大于 pivot 的元素都已归位。这样的操作称为一次快排。
- 优化：修改 pivot 的选择策略。比如随机选取，或者三者取中值。
- 时间复杂度：最好情况是每次 pivot 都处于数组中间位置，需要 logn 次快排，每次快排需要 O(n) 时间，复杂度为 O(nlogn)；最坏情况是比如第一个 pivot 正好在第一位，然后递归进去的第二个 pivot 正好在第二位，退化成冒泡排序，复杂度为  O(n^2)。
- 空间复杂度：内排序。但每次递归需要返回 pivot 的位置，所以空间复杂度是栈使用的空间O(logn）
- 稳定性：需要和 pivot 交换，会打乱顺序，不稳定。

##### 7. 堆排序

- 时间复杂度：始终为 O(nlogn)。
- 空间复杂度：O(1)，内排序。
- 稳定性：不稳定。

##### 8. 计数排序

- 原理：①根据数组元素的最大最小值得到桶数 k；②遍历所有元素，分到桶里并记录数量；③填充目标数组
- 特点：适用于小范围数组
- 时间复杂度：O(n)？。遍历时需要O(n)时间，
- 空间复杂度：O(k)。需要额外桶空间，外排序。
- 稳定性：稳定

##### 9. 桶排序

- 原理：人为指定每个桶中元素的数值范围，计算得桶数 k，将元素分到有限数量的桶里，每个桶再分别排序（此步可采用其它排序方式）
- 特点：适用于输入数据服从均匀分布的情况。
- 时间复杂度：O(n)？。遍历时需要O(n)时间，
- 空间复杂度：O(k+n)。需要额外桶空间，外排序。
- 稳定性：稳定

##### 10. 基数排序

- 原理：①找到数组最大值，得最大位数 maxDigit；②从最低位开始取每个位组成`radix`数组；③对`radix`进行计数排序（计数排序适用于小范围的特点）。
- 时间复杂度：O(maxDigit*n)？。
- 空间复杂度：O(k)。需要额外桶空间，外排序。
- 稳定性：稳定





